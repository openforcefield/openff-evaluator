from collections.abc import MutableMapping
from pathlib import Path
from typing import (
    Dict,
    Generator,
    Iterable,
    Iterator,
    List,
    Literal,
    Optional,
    TextIO,
    Tuple,
    Union,
)

import mdtraj
import openmm.app
from _typeshed import Incomplete
from networkx import Graph as Graph
from numpy.typing import NDArray as NDArray
from openff.toolkit.topology import Molecule
from openff.toolkit.topology._mm_molecule import _SimpleMolecule
from openff.toolkit.topology.molecule import Atom, FrozenMolecule
from openff.toolkit.topology.molecule import HierarchyElement as HierarchyElement
from openff.toolkit.utils.serialization import Serializable
from openff.units import Quantity, unit
from openmm.unit import Quantity as OMMQuantity

class TopologyDeprecationWarning(UserWarning): ...

class _TransformedDict(MutableMapping):
    store: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __keytransform__(self, key): ...
    @staticmethod
    def __sortfunc__(key): ...

class ValenceDict(_TransformedDict):
    @staticmethod
    def key_transform(key): ...
    @classmethod
    def index_of(cls, key, possible: Incomplete | None = ...): ...
    def __keytransform__(self, key): ...

class SortedDict(_TransformedDict):
    def __keytransform__(self, key): ...

class UnsortedDict(_TransformedDict): ...

class TagSortedDict(_TransformedDict):
    def __init__(self, *args, **kwargs) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def __keytransform__(self, key): ...
    def key_transform(self, key): ...
    def clear(self) -> None: ...

class ImproperDict(_TransformedDict):
    @staticmethod
    def key_transform(key): ...
    @classmethod
    def index_of(cls, key, possible: Incomplete | None = ...): ...
    def __keytransform__(self, key): ...

class Topology(Serializable):
    def __init__(self, other: Incomplete | None = ...) -> None: ...
    def __iadd__(self, other): ...
    def __add__(self, other): ...
    @property
    def unique_molecules(self) -> Iterator[Molecule]: ...
    @property
    def n_unique_molecules(self) -> int: ...
    @classmethod
    def from_molecules(cls, molecules: Union[Molecule, List[Molecule]]): ...
    def assert_bonded(self, atom1, atom2) -> None: ...
    @property
    def aromaticity_model(self): ...
    @aromaticity_model.setter
    def aromaticity_model(self, aromaticity_model) -> None: ...
    @property
    def box_vectors(self): ...
    @box_vectors.setter
    def box_vectors(self, box_vectors) -> None: ...
    @property
    def is_periodic(self): ...
    @is_periodic.setter
    def is_periodic(self, is_periodic) -> None: ...
    @property
    def constrained_atom_pairs(
        self,
    ) -> Dict[Tuple[int], Union[Quantity, bool]]: ...
    @property
    def n_molecules(self) -> int: ...
    @property
    def molecules(self) -> Generator[Union[Molecule, _SimpleMolecule], None, None]: ...
    def molecule(self, index): ...
    @property
    def n_atoms(self) -> int: ...
    @property
    def atoms(self) -> Generator["Atom", None, None]: ...
    def atom_index(self, atom): ...
    def molecule_index(self, molecule): ...
    def molecule_atom_start_index(self, molecule): ...
    @property
    def n_bonds(self): ...
    @property
    def bonds(self) -> Generator[Incomplete, None, None]: ...
    @property
    def n_angles(self): ...
    @property
    def angles(self) -> Generator[Incomplete, None, None]: ...
    @property
    def n_propers(self): ...
    @property
    def propers(self) -> Generator[Incomplete, None, None]: ...
    @property
    def n_impropers(self): ...
    @property
    def impropers(self) -> Generator[Incomplete, None, None]: ...
    @property
    def smirnoff_impropers(self) -> Generator[Incomplete, None, None]: ...
    @property
    def amber_impropers(self) -> Generator[Incomplete, None, None]: ...
    def nth_degree_neighbors(self, n_degrees: int): ...

    class _ChemicalEnvironmentMatch:
        @property
        def reference_atom_indices(self): ...
        @property
        def reference_molecule(self): ...
        @property
        def topology_atom_indices(self): ...
        def __init__(
            self, reference_atom_indices, reference_molecule, topology_atom_indices
        ) -> None: ...

    def chemical_environment_matches(
        self,
        query: str,
        aromaticity_model: str = ...,
        unique: bool = ...,
        toolkit_registry=...,
    ): ...
    @property
    def identical_molecule_groups(
        self,
    ) -> Dict[int, List[Tuple[int, Dict[int, int]]]]: ...
    def copy_initializer(self, other) -> None: ...
    def to_dict(self): ...
    @classmethod
    def from_dict(cls, topology_dict: dict): ...
    @classmethod
    def from_openmm(
        cls,
        openmm_topology: openmm.app.Topology,
        unique_molecules: Optional[Iterable[FrozenMolecule]] = ...,
        positions: Union[None, Quantity, "OMMQuantity"] = ...,
    ) -> Topology: ...
    def to_openmm(self, ensure_unique_atom_names: Union[str, bool] = ...): ...
    def to_file(
        self,
        file: Union[Path, str, TextIO],
        positions: Optional[Union["OMMQuantity", Quantity, NDArray]] = ...,
        file_format: Literal["PDB"] = ...,
        keep_ids: bool = ...,
        ensure_unique_atom_names: Union[str, bool] = ...,
    ): ...
    def get_positions(self) -> Optional[Quantity]: ...
    def set_positions(self, array: Quantity): ...
    @classmethod
    def from_mdtraj(
        cls,
        mdtraj_topology: mdtraj.Topology,
        unique_molecules: Optional[Iterable[FrozenMolecule]] = ...,
        positions: Union[None, "OMMQuantity", Quantity] = ...,
    ): ...
    def get_bond_between(self, i, j): ...
    def is_bonded(self, i, j): ...
    def atom(self, atom_topology_index): ...
    def bond(self, bond_topology_index): ...
    def add_molecule(self, molecule: Union[Molecule, _SimpleMolecule]) -> int: ...
    def add_constraint(self, iatom, jatom, distance: bool = ...) -> None: ...
    def is_constrained(self, iatom, jatom): ...
    def hierarchy_iterator(self, iter_name: str) -> Iterator[HierarchyElement]: ...
    @property
    def n_topology_atoms(self) -> int: ...
    @property
    def topology_atoms(self): ...
    @property
    def n_topology_bonds(self) -> int: ...
    @property
    def topology_bonds(self): ...
    @property
    def n_topology_particles(self) -> int: ...
    @property
    def topology_particles(self): ...
    @property
    def reference_molecules(self) -> Iterator[Molecule]: ...
    @property
    def n_reference_molecules(self) -> int: ...
    @property
    def n_topology_molecules(self) -> int: ...
    @property
    def topology_molecules(self): ...
    @property
    def n_particles(self) -> int: ...
    @property
    def particles(self): ...
    def particle_index(self, particle) -> int: ...
