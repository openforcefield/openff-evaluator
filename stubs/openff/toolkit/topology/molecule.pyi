from collections import UserDict
from typing import Any, Dict, Generator, List, Optional, Set, TextIO, Tuple, Union

import networkx as nx
from _typeshed import Incomplete
from openff.toolkit.utils.base_wrapper import ToolkitWrapper
from openff.toolkit.utils.serialization import Serializable
from openff.toolkit.utils.toolkit_registry import ToolkitRegistry
from openff.units import unit
from openff.units.unit import Quantity as Quantity

class MoleculeDeprecationWarning(UserWarning): ...

class Particle(Serializable):
    @property
    def molecule(self): ...
    @molecule.setter
    def molecule(self, molecule) -> None: ...
    @property
    def molecule_particle_index(self): ...
    @property
    def name(self): ...
    def to_dict(self) -> None: ...
    @classmethod
    def from_dict(cls, d) -> None: ...

class AtomMetadataDict(UserDict):
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def __setitem__(self, key, value) -> None: ...

class Atom(Particle):
    def __init__(
        self,
        atomic_number,
        formal_charge,
        is_aromatic,
        name: Incomplete | None = ...,
        molecule: Incomplete | None = ...,
        stereochemistry: Incomplete | None = ...,
        metadata: Incomplete | None = ...,
    ) -> None: ...
    def add_bond(self, bond) -> None: ...
    def to_dict(self): ...
    @classmethod
    def from_dict(cls, atom_dict): ...
    @property
    def metadata(self): ...
    @property
    def formal_charge(self): ...
    @formal_charge.setter
    def formal_charge(self, other) -> None: ...
    @property
    def partial_charge(self): ...
    @property
    def is_aromatic(self): ...
    @property
    def stereochemistry(self): ...
    @stereochemistry.setter
    def stereochemistry(self, value) -> None: ...
    @property
    def atomic_number(self) -> int: ...
    @property
    def symbol(self) -> str: ...
    @property
    def mass(self) -> Quantity: ...
    @property
    def name(self): ...
    @name.setter
    def name(self, other) -> None: ...
    @property
    def bonds(self): ...
    @property
    def bonded_atoms(self) -> Generator[Incomplete, None, None]: ...
    def is_bonded_to(self, atom2): ...
    def is_in_ring(self, toolkit_registry=...) -> bool: ...
    @property
    def molecule_atom_index(self): ...

class Bond(Serializable):
    def __init__(
        self,
        atom1,
        atom2,
        bond_order,
        is_aromatic,
        fractional_bond_order: Incomplete | None = ...,
        stereochemistry: Incomplete | None = ...,
    ) -> None: ...
    def to_dict(self) -> dict: ...
    @classmethod
    def from_dict(cls, molecule, d): ...
    @property
    def atom1(self): ...
    @property
    def atom2(self): ...
    @property
    def atom1_index(self): ...
    @property
    def atom2_index(self): ...
    @property
    def atoms(self): ...
    @property
    def bond_order(self): ...
    @bond_order.setter
    def bond_order(self, value) -> None: ...
    @property
    def fractional_bond_order(self): ...
    @fractional_bond_order.setter
    def fractional_bond_order(self, value) -> None: ...
    @property
    def stereochemistry(self): ...
    @property
    def is_aromatic(self): ...
    @property
    def molecule(self): ...
    @molecule.setter
    def molecule(self, value) -> None: ...
    @property
    def molecule_bond_index(self): ...
    def is_in_ring(self, toolkit_registry=...) -> bool: ...

class FrozenMolecule(Serializable):
    def __init__(
        self,
        other: Incomplete | None = ...,
        file_format: Incomplete | None = ...,
        toolkit_registry=...,
        allow_undefined_stereo: bool = ...,
    ) -> None: ...
    @property
    def has_unique_atom_names(self) -> bool: ...
    def generate_unique_atom_names(self): ...
    def strip_atom_stereochemistry(self, smarts: str, toolkit_registry=...): ...
    def to_dict(self) -> dict: ...
    def __hash__(self): ...
    def ordered_connection_table_hash(self): ...
    @classmethod
    def from_dict(cls, molecule_dict: dict): ...
    def __eq__(self, other): ...
    def __deepcopy__(self, memo): ...
    def add_default_hierarchy_schemes(self, overwrite_existing: bool = ...) -> None: ...
    def add_hierarchy_scheme(self, uniqueness_criteria, iterator_name): ...
    @property
    def hierarchy_schemes(self) -> Dict[str, "HierarchyScheme"]: ...
    def delete_hierarchy_scheme(self, iter_name) -> None: ...
    def update_hierarchy_schemes(self, iter_names: Incomplete | None = ...) -> None: ...
    def __getattr__(self, name: str): ...
    def __dir__(self): ...
    def to_smiles(
        self,
        isomeric: bool = ...,
        explicit_hydrogens: bool = ...,
        mapped: bool = ...,
        toolkit_registry=...,
    ): ...
    @classmethod
    def from_inchi(
        cls, inchi, allow_undefined_stereo: bool = ..., toolkit_registry=...
    ): ...
    def to_inchi(self, fixed_hydrogens: bool = ..., toolkit_registry=...): ...
    def to_inchikey(self, fixed_hydrogens: bool = ..., toolkit_registry=...): ...
    @classmethod
    def from_smiles(
        cls,
        smiles,
        hydrogens_are_explicit: bool = ...,
        toolkit_registry=...,
        allow_undefined_stereo: bool = ...,
    ): ...
    @staticmethod
    def are_isomorphic(
        mol1: Union["FrozenMolecule", nx.Graph],
        mol2: Union["FrozenMolecule", nx.Graph],
        return_atom_map: bool = ...,
        aromatic_matching: bool = ...,
        formal_charge_matching: bool = ...,
        bond_order_matching: bool = ...,
        atom_stereochemistry_matching: bool = ...,
        bond_stereochemistry_matching: bool = ...,
        strip_pyrimidal_n_atom_stereo: bool = ...,
        toolkit_registry=...,
    ): ...
    def is_isomorphic_with(
        self, other: Union["FrozenMolecule", nx.Graph], **kwargs
    ): ...
    def generate_conformers(
        self,
        toolkit_registry=...,
        n_conformers: int = ...,
        rms_cutoff: Incomplete | None = ...,
        clear_existing: bool = ...,
        make_carboxylic_acids_cis: bool = ...,
    ): ...
    def apply_elf_conformer_selection(
        self,
        percentage: float = ...,
        limit: int = ...,
        toolkit_registry: Optional[Union[ToolkitRegistry, ToolkitWrapper]] = ...,
        **kwargs
    ): ...
    def assign_partial_charges(
        self,
        partial_charge_method: str,
        strict_n_conformers: bool = ...,
        use_conformers: Incomplete | None = ...,
        toolkit_registry=...,
        normalize_partial_charges: bool = ...,
    ): ...
    def assign_fractional_bond_orders(
        self,
        bond_order_model: Incomplete | None = ...,
        toolkit_registry=...,
        use_conformers: Incomplete | None = ...,
    ): ...
    def to_networkx(self): ...
    def find_rotatable_bonds(
        self, ignore_functional_groups: Incomplete | None = ..., toolkit_registry=...
    ): ...
    @property
    def partial_charges(self): ...
    @partial_charges.setter
    def partial_charges(self, charges) -> None: ...
    @property
    def n_particles(self) -> int: ...
    @property
    def n_atoms(self) -> int: ...
    @property
    def n_bonds(self): ...
    @property
    def n_angles(self) -> int: ...
    @property
    def n_propers(self) -> int: ...
    @property
    def n_impropers(self) -> int: ...
    @property
    def particles(self) -> List[Atom]: ...
    def particle(self, index: int) -> Atom: ...
    def particle_index(self, particle: Atom) -> int: ...
    @property
    def atoms(self): ...
    def atom(self, index: int) -> Atom: ...
    def atom_index(self, atom: Atom) -> int: ...
    @property
    def conformers(self): ...
    @property
    def n_conformers(self) -> int: ...
    @property
    def bonds(self) -> List[Bond]: ...
    def bond(self, index: int) -> Bond: ...
    @property
    def angles(self) -> Set[Tuple[Atom, Atom, Atom]]: ...
    @property
    def torsions(self) -> Set[Tuple[Atom, Atom, Atom, Atom]]: ...
    @property
    def propers(self) -> Set[Tuple[Atom, Atom, Atom, Atom]]: ...
    @property
    def impropers(self) -> Set[Tuple[Atom, Atom, Atom, Atom]]: ...
    @property
    def smirnoff_impropers(self) -> Set[Tuple[Atom, Atom, Atom, Atom]]: ...
    @property
    def amber_impropers(self) -> Set[Tuple[Atom, Atom, Atom, Atom]]: ...
    def nth_degree_neighbors(self, n_degrees): ...
    @property
    def total_charge(self): ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, other) -> None: ...
    @property
    def properties(self) -> Dict[str, Any]: ...
    @property
    def hill_formula(self) -> str: ...
    def to_hill_formula(self) -> str: ...
    def chemical_environment_matches(
        self, query: str, unique: bool = ..., toolkit_registry=...
    ): ...
    @classmethod
    def from_iupac(
        cls,
        iupac_name,
        toolkit_registry=...,
        allow_undefined_stereo: bool = ...,
        **kwargs
    ): ...
    def to_iupac(self, toolkit_registry=...): ...
    @classmethod
    def from_topology(cls, topology): ...
    def to_topology(self): ...
    @classmethod
    def from_file(
        cls,
        file_path,
        file_format: Incomplete | None = ...,
        toolkit_registry=...,
        allow_undefined_stereo: bool = ...,
    ): ...
    @classmethod
    def from_polymer_pdb(cls, file_path: Union[str, TextIO], toolkit_registry=...): ...
    def to_file(self, file_path, file_format, toolkit_registry=...): ...
    def enumerate_tautomers(self, max_states: int = ..., toolkit_registry=...): ...
    def enumerate_stereoisomers(
        self,
        undefined_only: bool = ...,
        max_isomers: int = ...,
        rationalise: bool = ...,
        toolkit_registry=...,
    ): ...
    def enumerate_protomers(self, max_states: int = ...): ...
    @classmethod
    def from_rdkit(
        cls,
        rdmol,
        allow_undefined_stereo: bool = ...,
        hydrogens_are_explicit: bool = ...,
    ): ...
    def to_rdkit(self, aromaticity_model=..., toolkit_registry=...): ...
    @classmethod
    def from_openeye(cls, oemol, allow_undefined_stereo: bool = ...): ...
    def to_qcschema(
        self,
        multiplicity: int = ...,
        conformer: int = ...,
        extras: Incomplete | None = ...,
    ): ...
    @classmethod
    def from_mapped_smiles(
        cls, mapped_smiles, toolkit_registry=..., allow_undefined_stereo: bool = ...
    ): ...
    @classmethod
    def from_qcschema(
        cls,
        qca_record,
        client: Incomplete | None = ...,
        toolkit_registry=...,
        allow_undefined_stereo: bool = ...,
    ): ...
    @classmethod
    def from_pdb_and_smiles(
        cls, file_path, smiles, allow_undefined_stereo: bool = ...
    ): ...
    def canonical_order_atoms(self, toolkit_registry=...): ...
    def remap(self, mapping_dict, current_to_new: bool = ...): ...
    def to_openeye(self, toolkit_registry=..., aromaticity_model=...): ...
    def get_bond_between(self, i, j): ...

class Molecule(FrozenMolecule):
    def __init__(self, *args, **kwargs) -> None: ...
    def add_atom(
        self,
        atomic_number,
        formal_charge,
        is_aromatic,
        stereochemistry: Incomplete | None = ...,
        name: Incomplete | None = ...,
        metadata: Incomplete | None = ...,
    ): ...
    def add_bond(
        self,
        atom1,
        atom2,
        bond_order,
        is_aromatic,
        stereochemistry: Incomplete | None = ...,
        fractional_bond_order: Incomplete | None = ...,
    ): ...
    def add_conformer(self, coordinates): ...
    def visualize(
        self,
        backend: str = ...,
        width: Incomplete | None = ...,
        height: Incomplete | None = ...,
        show_all_hydrogens: bool = ...,
    ): ...
    def perceive_residues(
        self,
        substructure_file_path: Incomplete | None = ...,
        strict_chirality: bool = ...,
    ): ...

class HierarchyScheme:
    parent: Incomplete
    uniqueness_criteria: Incomplete
    iterator_name: Incomplete
    hierarchy_elements: Incomplete
    def __init__(
        self,
        parent: FrozenMolecule,
        uniqueness_criteria: Union[Tuple[str], List[str]],
        iterator_name: str,
    ) -> None: ...
    def to_dict(self): ...
    def perceive_hierarchy(self) -> None: ...
    def add_hierarchy_element(self, identifier, atom_indices): ...
    def sort_hierarchy_elements(self): ...

class HierarchyElement:
    scheme: Incomplete
    identifier: Incomplete
    atom_indices: Incomplete
    def __init__(self, scheme, identifier, atom_indices) -> None: ...
    def to_dict(self): ...
    @property
    def n_atoms(self): ...
    @property
    def atoms(self) -> Generator[Incomplete, None, None]: ...
    def atom(self, index: int) -> Atom: ...
    @property
    def parent(self) -> FrozenMolecule: ...
    @property
    def has_unique_atom_names(self) -> bool: ...
    def generate_unique_atom_names(self): ...
